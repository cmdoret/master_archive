---
title: "GC content and recombination"
author: "Cyril Matthey-Doret"
date: "17.05.2018"
output: 
  html_notebook:
    code_folding: hide
---

## Summary
In this notebook, I document 2 separate analyses. In the first part, I compute GC content along 1) the reference genome and 2) the WGS wild samples. GC content is expected to increase in regions with high recombination rates. We can use this information as an additional support for the location of centromeres (low recombination rates). WGS samples should work better than the reference genome, because they are sexual, whereas the reference was built using asexual samples. 

In the second part, I discuss potential strategies and tools to build a linkage map from the RADseq samples (i.e. females, haploid and diploid males). The main issues here are the small sizes of families and the different ploidies between individuals.

## GC Content
Here I measure GC content along the reference genome and the WGS samples to get a second measure of recombination rate. I also infer location of centromeres and compare it to the regions obtained previously from RADseq data. I am currently computing GC% in sliding windows of 10kb.


```{bash format_reference}
# Genome needs to be easily machine readable for sliding windows 
# -> convert from FASTA into tabular (tab separated) format (Chr,pos,Allele)

ref_dir='../../../../data/ref_genome/ordered_genome/'
# BSD sed does not recognize tabs -> insert w/variable
TAB=$'\t'
declare -i SEQ=0
mkdir -p temp_chr  # Create temporary directory to store 1 file per chromosome

# Removes newlines from sequences in genome
awk '!/^>/ { printf "%s", $0; n = "\n" } 
     /^>/ { print n $0; n = "" }
     END { printf "%s", n }' "$ref_dir/merged.fasta" > single_line.fasta

# reading FASTA records
while read record
do
  # If header matches chromosome (i.e. not an unanchored contig)
  if [[ $record = ">chr"* ]]
  then
    ID="${record//>}"
    # Authorize to process corresponding sequence
    SEQ=1
  else
    # Is this a chromosome sequence ?
    if [[ $SEQ -eq 1 ]]
    then
      # Prints 1 base per line and prepends chromosome name
      fold -w1 <(echo $record) | sed "s/^/$ID${TAB}/" > temp_chr/$ID.tmp
      # Don't process unanchored sequences
      SEQ=0
    fi
  fi
done < single_line.fasta

# Concatenates each file, prepending line number (i.e. nucleotide positions)
cat -n temp_chr/*.tmp > ref_table.tsv

# Clean temporary directory
rm -r temp_chr single_line.fasta
mv ref_table.tsv $ref_dir/ref_table.tsv

```

```{r load, echo=F}
## Packages
packs <- c("readr", "dplyr", "ggplot2", "Rcpp", "RcppRoll", "viridis")
packs <- sapply(packs, function(x) suppressPackageStartupMessages(library(x, quietly=T, character.only=T)))

## Variables
zoom <- 10**6 # Basepair unit (10^6 -> Mb)
options(readr.show_progress=F) # Read files silently

## Data
# Reference genome
ref_table <- read_tsv("../../../../data/ref_genome/ordered_genome/ref_table.tsv", 
                      col_names = F, col_types = cols())
ref_table <- ref_table[,c(2,1,3)]
colnames(ref_table) <- c("Chr", "BP", "Nuc")
# WGS samples


```

```{r format}
ref_table <- ref_table %>% 
  mutate(GC = ifelse(Nuc %in% c("G", "C"), 1, 0))

knitr::kable(ref_table %>% 
               group_by(Chr) %>% 
               summarize(`Mean GC%` = mean(GC) %>% round(2), 
                         `Stdev GC%` = sd(GC) %>% round(2)), 
             caption= "Summary statistics of GC content on each chromosome", 
             format = "html", table.attr = "style='width:40%;'", align = 'c')

```

### Reference genome

The figure belows shows the GC content of the reference genome (based on asexuals) in the form of hexbins. The plotting space is divided into a hexagonal grid and the number of windows falling in each sector is used to visualize the distribution of GC content.

```{r ref_GC, dpi=400}

# Sliding window parameters for GC content
win_size=10000;win_step=100

# Computes GC% in windows along the genome
slide_GC <- function(mat, pos, win, step){
  
  # Check whether parameters make sense
  if(any(win > max(pos), step == 0, win == 0, step > win)){
    print("Bad input parameters. Is your step size > window size, or matrix smaller than window ?")
    return()
  }
  # All possible coordinates for window starts
  win_start <- seq(1, (max(pos) - (win-1)), step)
  # Total number of windows
  n_win <- ceiling((max(pos)-(win-1))/step)
  # Initialize output structure to contain original index and GC
  out_mat <- matrix(nrow=n_win, ncol=3, byrow = F)
  out_mat[,1] <- win_start
  out_mat[,2] <- out_mat[,1] + win
  #print(sprintf("Computing %i windows...", n_win))
  # Compute GC in all SNPs within window boundaries
  mat_GC <- RcppRoll::roll_mean(mat, n = win, by = step, align = 'left', na.rm=T)
  out_mat[,3] <- mat_GC[seq(1,nrow(mat_GC),by=step),]
  return(out_mat)
}

out <- tibble()
for(chr in unique(pull(ref_table, 1))){
  GCwin <- slide_GC(mat=matrix(ref_table$GC[ref_table$Chr==chr], ncol=1), 
                    pos=ref_table$BP[ref_table$Chr==chr], 
                    win=win_size, step = win_step)
  GCwin <- as_tibble(GCwin) %>% mutate(Chr=chr)
  out <- bind_rows(out, GCwin)
}

ref_GC <- out %>% rename(start = V1, end = V2, GC = V3)


ggplot(ref_GC, aes(x=(start+end)/(2*zoom), y=GC)) + 
  facet_wrap(~Chr, scales = 'free_x') +
  stat_bin_hex() + 
  theme_minimal() +
  scale_fill_viridis() + 
  ggtitle(sprintf("GC content along reference genome [%i bp windows]", win_size)) + 
  ylab("GC%") + xlab("Position [Mb]")

```

### WGS samples

These samples should give more insight into the location of centromeres as they are originate from sexual families. This means recombination should still havppen between the parents and therefore, GC-biased gene conversion should occur.

```{wgs_GC}
# TODO: get genotype matrix (in nucleotides, not int...) 
# -> use the TGT option in bcftools query expression
slide_GC(mat = wgs_table, pos = , win = win_size, step = win_step)

```

### Comparison with RADseq centromeres

```{r comp_RAD}
# TODO: regenerate centromere plot with Makefile
knitr::include_graphics('')
```

## Notes on linkage map
I want to make a linkage map from the RADseq data from the CSD project. Here is a summary of Dan's advice to produce the map.

### 3 ways to build a map

1. Combining maps from different families using **ALLMAPS**: Might require to hack genetic distances between markers of different maps at the end.
    + Really small families are not worth trying, they would probably add more noise (genotyping errors) than information (meioses) to the picture. **Should just use the one or two largest families**.
    + I don't have many markers. "Good": The more loci available, the more meioses (offspring) are needed to resolve their order.

2. **Lepmap** is a linkage mapping software that takes multiple families, and produces a single map, combining all of them. Might not work with haplodiploids. 

3. There is one function in ALLMAPS which calculates the relationship between physical and genetic distance (which changes along the chromosome). So if I only manage to include one or two families, I could **combine this with the family from Jens' map**, work out the bp vs cM relationship, and then just convert the physical distances between your markers of interest into genetic distances. Could be a good alternative approach, even if you can only use Jens' map actually. 

### 2 ways to validate

1. Looking at the number of loci in each linkage group. There should be a noticable step down in the number of tags in these groups. How noticeable this step is can give an idea of how well the linkage mapping software has been able to group loci into linkage groups. 
2. Map tags to the reference contigs/scaffolds (before anchoring). If the physical order tag alignments matches the linkage map order on scaffolds that have a good number (say >5) tags mapping to them, then it provides some confidence that the map is OK.

### Plan

I'll try to work with Lepmap3. It is among the best options in terms of speed and accuracy (uses genotype likelihoods, not only genotypes). And most importantly, it works with multiple families and does not require phased haplotypes. The drawback is that it doesn't handle haplodiploids.

To work around the haplodiploid issue I will duplicate haploid alleles and all diploid samples. I will perform the analysis with only "synthetic" diploids but the same representation of each allele in the population as with the original data.

0. Diploidize population
1. Generate input vcf file
2. Filter SNPs (segregation distortion, quality)
3. Build linkage map
