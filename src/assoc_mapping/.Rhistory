geom_path(data=m.country[m.country$diverg!='Outgroup',], alpha=0.6, lty=2, aes(x = b, y=nbr_country, group=pair)) +
geom_boxplot(width=0.1) +
theme_classic() + theme(axis.line.x = element_line (color="black"), axis.line.y = element_line (color="black")) +
ylab("Number of countries") + xlab("") +
annotate("text", x=1.5, y=max(m.country$nbr_country[m.country$diverg!="Parthenogen"]*1.1, na.rm=T),
label="p = 0.0006", size=4)
grid.arrange(line.host, line.country, nrow=1, ncol=2)
test_var <- "host_spp" # This line allows to choose the variable to be tested
merged$pair <- as.factor(merged$pair)
mod_data <- merged[merged$diverg!='Parthenogen',]
# Excluding asexuals to compare only sister species versus outgroup
my_model <- glmer(mod_data[,test_var] ~ diverg + (1|pair), data = mod_data, family="poisson")
z.obs <- coef(summary(my_model))[2, "z value"]
z.obs
n.pairs <- length(levels(mod_data$pair)) #number of genera
l.genus <- as.vector(table(mod_data$genus)) #list w/ number of species per genus
nboot <- 10 #number of permutations
zval_model <- function(data, n.pairs, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(x= character(0), y= character(0), z = character(0))
for (t in 1:n.pairs) {
# Sub data frame (for each pair).
part_distri <- random_test(data, levels(data$pair)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(pair_var ~ random_diverg + (1|genus_name/pair_name), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(pair_var ~ random_diverg + (1|genus_name/pair_name), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
ifelse(test_var %in% c("nbr_country", "host_spp"), T, F)
count <- ifelse(test_var %in% c("nbr_country", "host_spp"), T, F)
zval.reference <- replicate(nboot, zval_model(mod_data, n.pairs))
n.pairs <- length(levels(mod_data$pair)) #number of genera
l.genus <- as.vector(table(mod_data$genus)) #list w/ number of species per genus
nboot <- 10 #number of permutations
random_test <- function(x,y) {  #x: merged, y:genus
pair_name <- subset(x, pair == y)$pair
species_name <- subset(x, pair == y)$species
pair_var <- subset(x, pair == y)[,test_var]
genus_name <- subset(x, pair == y)$genus
# Sample without replacement
random_diverg <- sample(subset(x, pair == y)$diverg)
# Return a partial data frame (for each genus)
return(data.frame(pair_name, genus_name, species_name, pair_var, random_diverg))
}
####################################################
# For each pair, run the random_test() function.
zval_model <- function(data, n.pairs, count=F){
# Complete data frame initialization.
ref.distri <- data.frame(x= character(0), y= character(0), z = character(0))
for (t in 1:n.pairs) {
# Sub data frame (for each pair).
part_distri <- random_test(data, levels(data$pair)[t])
# Concatenation of each sub data frames.
ref.distri <- rbind(ref.distri, part_distri)
}
#print(ref.distri)
# Model
if(count){
m1 <- glmer(pair_var ~ random_diverg + (1|genus_name/pair_name), data = ref.distri,family = "poisson")
st <- "z"
} else{
m1 <- lmer(pair_var ~ random_diverg + (1|genus_name/pair_name), data = ref.distri)
st <- "t"
}
return(coef(summary(m1))[2, paste0(st," value")]) # Return zvalue
}
####################################################
# Main
count <- ifelse(test_var %in% c("nbr_country", "host_spp"), T, F)
zval.reference <- replicate(nboot, zval_model(mod_data, n.pairs))
hist(zval.reference, breaks = 30, xlim=c(-60, 60)) # Vector of nboot pvalues.
abline(v=z.obs, col="red", lwd=3)
quantile(zval.reference,c(0.025, 0.975))
sum(z.obs>zval.reference)/nboot
test_var <- latitude_mean
test_var <- "latitude_mean"
count <- ifelse(test_var %in% c("nbr_country", "host_spp"), T, F)
zval.reference <- replicate(nboot, zval_model(mod_data, n.pairs))
hist(zval.reference, breaks = 30, xlim=c(-60, 60)) # Vector of nboot pvalues.
abline(v=z.obs, col="red", lwd=3)
quantile(zval.reference,c(0.025, 0.975))
sum(z.obs>zval.reference)/nboot
library(ggplot2); library(dplyr)
stat_path <- '../../data/populations/d-5_r-10/'
indv <- read.table('../../data/individuals', header=T)
grouped <- "T"
if(grouped=='F'){
sum_stat <- data.frame()
for(fam in list.dirs(stat_path)[2:length(list.dirs(stat_path))]){  # Excluding first dir (parent)
tmp_stat <- read.csv(paste0(fam,'/batch_0.sumstats.tsv'),header=T,skip=2,sep='\t')
tmp_stat$fam <- rep(basename(fam))
sum_stat <- rbind(sum_stat, tmp_stat)
mother_hom <- NULL
}
rm_snps<- sum_stat %>%
group_by(fam,Locus.ID,Col) %>%  # Each group contains one SNP (both male and female pop)
summarise(hom_mot = sum(Pop.ID=='F' & Q.Nuc=='-'))  # If all females are homozygous -> mother is homozygous
rm_snps <- rm_snps[rm_snps$hom_mot==0, 1:3]
sum_stat <- merge(sum_stat,rm_snps,by=c("Locus.ID","Col","fam"))
}else{
sum_stat <- read.csv(paste0(stat_path,"/batch_0.sumstats.tsv"), header=T, skip=2, sep='\t')
sum_stat$fam <- 'all'
}
male_stat <- sum_stat[sum_stat$Pop.ID=="M",c('Chr','BP','Obs.Hom', 'fam', 'N',"Locus.ID")]
female_stat <- sum_stat[sum_stat$Pop.ID=="F",c('Chr','BP','Obs.Hom', 'fam', 'N')]
chrom_stat <- merge(male_stat,female_stat,by=c('Chr','BP','fam'))
attach(chrom_stat)
chrom_stat$hom <- (Obs.Hom.x * N.x + Obs.Hom.y * N.y)/(N.x + N.y)
chrom_stat <- rename(chrom_stat, Nm=N.x,Nf=N.y, Male.Hom=Obs.Hom.x, Fem.Hom=Obs.Hom.y)
getwd()
setwd("~/Documents/Master/master_project/src/assoc_mapping/")
stat_path <- '../../data/populations/d-5_r-10/'
indv <- read.table('../../data/individuals', header=T)
grouped <- "T"
if(grouped=='F'){
sum_stat <- data.frame()
for(fam in list.dirs(stat_path)[2:length(list.dirs(stat_path))]){  # Excluding first dir (parent)
tmp_stat <- read.csv(paste0(fam,'/batch_0.sumstats.tsv'),header=T,skip=2,sep='\t')
tmp_stat$fam <- rep(basename(fam))
sum_stat <- rbind(sum_stat, tmp_stat)
mother_hom <- NULL
}
rm_snps<- sum_stat %>%
group_by(fam,Locus.ID,Col) %>%  # Each group contains one SNP (both male and female pop)
summarise(hom_mot = sum(Pop.ID=='F' & Q.Nuc=='-'))  # If all females are homozygous -> mother is homozygous
rm_snps <- rm_snps[rm_snps$hom_mot==0, 1:3]
sum_stat <- merge(sum_stat,rm_snps,by=c("Locus.ID","Col","fam"))
}else{
sum_stat <- read.csv(paste0(stat_path,"/batch_0.sumstats.tsv"), header=T, skip=2, sep='\t')
sum_stat$fam <- 'all'
}
male_stat <- sum_stat[sum_stat$Pop.ID=="M",c('Chr','BP','Obs.Hom', 'fam', 'N',"Locus.ID")]
female_stat <- sum_stat[sum_stat$Pop.ID=="F",c('Chr','BP','Obs.Hom', 'fam', 'N')]
chrom_stat <- merge(male_stat,female_stat,by=c('Chr','BP','fam'))
attach(chrom_stat)
chrom_stat$hom <- (Obs.Hom.x * N.x + Obs.Hom.y * N.y)/(N.x + N.y)
chrom_stat <- rename(chrom_stat, Nm=N.x,Nf=N.y, Male.Hom=Obs.Hom.x, Fem.Hom=Obs.Hom.y)
chrom_stat$weight <- chrom_stat$Nf + chrom_stat$Nm
chrom_stat <- chrom_stat[grep("chr.*", chrom_stat$Chr),]
chrom_stat$Chr <- droplevels(chrom_stat$Chr)
ggplot(chrom_stat, aes(x=BP, y=hom, weight=weight)) + facet_grid(~Chr, scales='free_x') +
geom_point(col='grey70') + stat_smooth(fill='steelblue', method='loess', fullrange = F, span=0.4)
View(indv)
chr_models <- list()
for(chrom in levels(chrom_stat$Chr)){
chr_models[[chrom]] <- loess(data=chrom_stat[chrom_stat$Chr==chrom,],
formula=hom~BP, weights=weight, span=1, model=T)
}
library(viridis)
sp_range <- seq(0.2,1,0.05)
virilist <- viridis(n=length(sp_range))
colindex <- 1
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
for(sp in sp_range){
mod <- loess(data=chrom_stat[chrom_stat$Chr==chrom,], degree=1,
formula=hom~BP, weights=weight, span=sp, model=T)
points(mod$x[order(mod$x)],mod$fitted[order(mod$x)], type='l',col=alpha(virilist[colindex],0.4))
points(mod$x[mod$fitted==min(mod$fitted)],rep(-0.01,length(mod$x[mod$fitted==min(mod$fitted)])),
col=alpha(virilist[colindex],0.4),pch=16, cex=1.5)
colindex <- colindex+1
}
colindex <- 1
}
library(viridis)
sp_range <- seq(0.01,0.1,0.01)
virilist <- viridis(n=length(sp_range))
colindex <- 1
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
for(sp in sp_range){
mod <- loess(data=chrom_stat[chrom_stat$Chr==chrom,], degree=1,
formula=hom~BP, weights=weight, span=sp, model=T)
points(mod$x[order(mod$x)],mod$fitted[order(mod$x)], type='l',col=alpha(virilist[colindex],0.4))
points(mod$x[mod$fitted==min(mod$fitted)],rep(-0.01,length(mod$x[mod$fitted==min(mod$fitted)])),
col=alpha(virilist[colindex],0.4),pch=16, cex=1.5)
colindex <- colindex+1
}
colindex <- 1
}
library(viridis)
sp_range <- seq(0.03,0.2,0.01)
virilist <- viridis(n=length(sp_range))
colindex <- 1
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
for(sp in sp_range){
mod <- loess(data=chrom_stat[chrom_stat$Chr==chrom,], degree=1,
formula=hom~BP, weights=weight, span=sp, model=T)
points(mod$x[order(mod$x)],mod$fitted[order(mod$x)], type='l',col=alpha(virilist[colindex],0.4))
points(mod$x[mod$fitted==min(mod$fitted)],rep(-0.01,length(mod$x[mod$fitted==min(mod$fitted)])),
col=alpha(virilist[colindex],0.4),pch=16, cex=1.5)
colindex <- colindex+1
}
colindex <- 1
}
library(ggplot2); library(dplyr)
stat_path <- '../../data/populations/d-5_r-10/'
indv <- read.table('../../data/individuals', header=T)
grouped <- "T"
if(grouped=='F'){
sum_stat <- data.frame()
for(fam in list.dirs(stat_path)[2:length(list.dirs(stat_path))]){  # Excluding first dir (parent)
tmp_stat <- read.csv(paste0(fam,'/batch_0.sumstats.tsv'),header=T,skip=2,sep='\t')
tmp_stat$fam <- rep(basename(fam))
sum_stat <- rbind(sum_stat, tmp_stat)
mother_hom <- NULL
}
rm_snps<- sum_stat %>%
group_by(fam,Locus.ID,Col) %>%  # Each group contains one SNP (both male and female pop)
summarise(hom_mot = sum(Pop.ID=='F' & Q.Nuc=='-'))  # If all females are homozygous -> mother is homozygous
rm_snps <- rm_snps[rm_snps$hom_mot==0, 1:3]
sum_stat <- merge(sum_stat,rm_snps,by=c("Locus.ID","Col","fam"))
}else{
sum_stat <- read.csv(paste0(stat_path,"/batch_0.sumstats.tsv"), header=T, skip=2, sep='\t')
sum_stat$fam <- 'all'
}
male_stat <- sum_stat[sum_stat$Pop.ID=="M",c('Chr','BP','Obs.Hom', 'fam', 'N',"Locus.ID")]
female_stat <- sum_stat[sum_stat$Pop.ID=="F",c('Chr','BP','Obs.Hom', 'fam', 'N')]
chrom_stat <- merge(male_stat,female_stat,by=c('Chr','BP','fam'))
attach(chrom_stat)
chrom_stat$hom <- (Obs.Hom.x * N.x + Obs.Hom.y * N.y)/(N.x + N.y)
chrom_stat <- rename(chrom_stat, Nm=N.x,Nf=N.y, Male.Hom=Obs.Hom.x, Fem.Hom=Obs.Hom.y)
chrom_stat$weight <- chrom_stat$Nf + chrom_stat$Nm
chrom_stat <- chrom_stat[grep("chr.*", chrom_stat$Chr),]
chrom_stat$Chr <- droplevels(chrom_stat$Chr)
ggplot(chrom_stat, aes(x=BP, y=hom, weight=weight)) + facet_grid(~Chr, scales='free_x') +
geom_point(col='grey70') + stat_smooth(fill='steelblue', method='loess', fullrange = F, span=0.4)
library(viridis)
sp_range <- seq(0.03,0.2,0.01)
virilist <- viridis(n=length(sp_range))
colindex <- 1
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
for(sp in sp_range){
mod <- loess(data=chrom_stat[chrom_stat$Chr==chrom,], degree=1,
formula=hom~BP, weights=weight, span=sp, model=T)
points(mod$x[order(mod$x)],mod$fitted[order(mod$x)], type='l',col=alpha(virilist[colindex],0.4))
points(mod$x[mod$fitted==min(mod$fitted)],rep(-0.01,length(mod$x[mod$fitted==min(mod$fitted)])),
col=alpha(virilist[colindex],0.4),pch=16, cex=1.5)
colindex <- colindex+1
}
colindex <- 1
}
loessGCV <- function (x) {
## Modified from code by Michael Friendly
## http://tolstoy.newcastle.edu.au/R/help/05/11/15899.html
if (!(inherits(x,"loess"))) stop("Error: argument must be a loess object")
## extract values from loess object
span <- x$pars$span
n <- x$n
traceL <- x$trace.hat
sigma2 <- sum(resid(x)^2) / (n-1)
gcv  <- n*sigma2 / (n-traceL)^2
result <- list(span=span, gcv=gcv)
result
}
library(viridis)
sp_range <- seq(0.02,0.2,0.01)
virilist <- viridis(n=length(sp_range))
colindex <- 1
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
for(sp in sp_range){
mod <- loess(data=chrom_stat[chrom_stat$Chr==chrom,], degree=1,
formula=hom~BP, weights=weight, span=sp, model=T)
points(mod$x[order(mod$x)],mod$fitted[order(mod$x)], type='l',col=alpha(virilist[colindex],0.4))
points(mod$x[mod$fitted==min(mod$fitted)],rep(-0.01,length(mod$x[mod$fitted==min(mod$fitted)])),
col=alpha(virilist[colindex],0.4),pch=16, cex=1.5)
colindex <- colindex+1
}
colindex <- 1
}
warnings()
loessGCV <- function (x) {
## Modified from code by Michael Friendly
## http://tolstoy.newcastle.edu.au/R/help/05/11/15899.html
if (!(inherits(x,"loess"))) stop("Error: argument must be a loess object")
## extract values from loess object
span <- x$pars$span
n <- x$n
traceL <- x$trace.hat
sigma2 <- sum(resid(x)^2) / (n-1)
gcv  <- n*sigma2 / (n-traceL)^2
result <- list(span=span, gcv=gcv)
result
}
estLoess <- function(model, spans = c(.1, .95)) {
f <- function(span) {
mod <- update(model, span = span)
loessGCV(mod)[["gcv"]]
}
result <- optimize(f, spans)
result
}
library(viridis)
sp_range <- seq(0.2,1,0.05)
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
mod <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], hom ~ BP,
weights = weight)
mod.best <- estLoess(mod)
mod.cv <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], formula=hom~BP,
degree=2, weights=weight, span=mod.best$minimum, model=T)
points(mod.cv$x[order(mod.cv$x)],mod.cv$fitted[order(mod.cv$x)], type='l')
points(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)],rep(-0.01,length(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)])),
pch=16, cex=1.5)
}
mod$n
?loess
mod$pars
mod$trace.hat
c(.01, .95)
loessGCV <- function (x) {
## Modified from code by Michael Friendly
## http://tolstoy.newcastle.edu.au/R/help/05/11/15899.html
if (!(inherits(x,"loess"))) stop("Error: argument must be a loess object")
## extract values from loess object
span <- x$pars$span
n <- x$n
traceL <- x$trace.hat
sigma2 <- sum(resid(x)^2) / (n-1)
gcv  <- n*sigma2 / (n-traceL)^2
result <- list(span=span, gcv=gcv)
result
}
estLoess <- function(model, spans = c(.01, .95)) {
f <- function(span) {
mod <- update(model, span = span)
loessGCV(mod)[["gcv"]]
}
result <- optimize(f, spans)
result
}
sp_range <- seq(0.2,1,0.05)
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
mod <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], hom ~ BP,
weights = weight)
mod.best <- estLoess(mod)
mod.cv <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], formula=hom~BP,
degree=2, weights=weight, span=mod.best$minimum, model=T)
points(mod.cv$x[order(mod.cv$x)],mod.cv$fitted[order(mod.cv$x)], type='l')
points(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)],rep(-0.01,length(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)])),
pch=16, cex=1.5)
}
loessGCV <- function (x) {
## Modified from code by Michael Friendly
## http://tolstoy.newcastle.edu.au/R/help/05/11/15899.html
if (!(inherits(x,"loess"))) stop("Error: argument must be a loess object")
## extract values from loess object
span <- x$pars$span
n <- x$n
traceL <- x$trace.hat
sigma2 <- sum(resid(x)^2) / (n-1)
gcv  <- n*sigma2 / (n-traceL)^2
result <- list(span=span, gcv=gcv)
result
}
estLoess <- function(model, spans = c(.01, .95)) {
f <- function(span) {
mod <- update(model, span = span)
loessGCV(mod)[["gcv"]]
}
result <- optimize(f, spans)
result
}
sp_range <- seq(0.2,1,0.05)
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
mod <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], hom ~ BP,
weights = weight)
mod.best <- estLoess(mod, spans = sp_range)
mod.cv <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], formula=hom~BP,
degree=2, weights=weight, span=mod.best$minimum, model=T)
points(mod.cv$x[order(mod.cv$x)],mod.cv$fitted[order(mod.cv$x)], type='l')
points(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)],rep(-0.01,length(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)])),
pch=16, cex=1.5)
}
sp_range <- seq(0.01,1,0.05)
sp_range
par(mfrow=c(3,2))
for(chrom in levels(chrom_stat$Chr)){
plot(x=c(),y=c(),xlim=c(0,max(chrom_stat$BP[chrom_stat$Chr==chrom])), ylim=c(-0.05,1))
abline(h=-0.01)
mod <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], hom ~ BP,
weights = weight)
mod.best <- estLoess(mod, spans = sp_range)
mod.cv <- loess(data = chrom_stat[chrom_stat$Chr==chrom,], formula=hom~BP,
degree=2, weights=weight, span=mod.best$minimum, model=T)
points(mod.cv$x[order(mod.cv$x)],mod.cv$fitted[order(mod.cv$x)], type='l')
points(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)],rep(-0.01,length(mod.cv$x[mod.cv$fitted==min(mod.cv$fitted)])),
pch=16, cex=1.5)
}
?optimize
library(ggplot2)
library(dplyr)
library(tidyr)
depth <- read.table("../../data/coverage/site_depth.txt", header=T)  # Loading data
depth <- depth[grep("chr*",depth$CHROM),]
depth$CHROM <- droplevels(depth$CHROM)
depth$POS <- round(depth$POS, digits=-3)
depth <- depth %>%
group_by(CHROM, POS, Family) %>%
mutate(avg=mean(MEAN_DEPTH)) %>%
select(-MEAN_DEPTH) %>%
rename(MEAN_DEPTH=avg)
depth <- subset(depth, !duplicated(subset(
depth, select=c(CHROM, POS, Family))))
sp_depth <- spread(depth,Family,MEAN_DEPTH)
sp_depth <- sp_depth[rowSums(!is.na(sp_depth[,3:14]))>0,]
ggplot(data=depth,aes(x=POS,y=MEAN_DEPTH,col=Family)) +
facet_grid(CHROM~., scales = 'free_x') + geom_point(size=0.3) +
geom_line(alpha=0.4) + theme_bw() + ggtitle("Coverage across genome, 1kb windows") +
xlab("Genomic position of SNP") + ylab("Mean coverage")
mergecov <- depth
ggplot(data=depth,(aes(x=POS,y=MEAN_DEPTH,col=Family))) +
facet_grid(~CHROM,scales = 'free_x') + geom_point(alpha=0.3)
slide <- data.frame()
for(chr in levels(mergecov$CHROM)){
for(bp in unique(mergecov$POS[mergecov$CHROM==chr])){
curr <- data.frame(chr,bp,round(mean(mergecov$MEAN_DEPTH[mergecov$POS==bp & mergecov$CHROM==chr]),3))
slide <- rbind(slide,curr)
}
}
colnames(slide) <- c("CHROM","POS","DEPTH")
colnames(slide) <- c("CHROM","POS","DEPTH")
ggplot(data=slide,aes(x=POS,y=DEPTH)) + geom_line() + facet_wrap(~CHROM,scales = 'free_x')
ggplot(data=depth,aes(x=POS,y=MEAN_DEPTH,col=Family)) +
facet_grid(CHROM~., scales = 'free_x') + geom_point(size=0.3) +
geom_line(alpha=0.4) + theme_bw() + ggtitle("Coverage across genome, 1kb windows") +
xlab("Genomic position of SNP") + ylab("Mean coverage")
hist(depth$MEAN_DEPTH)
hist(depth$MEAN_DEPTH, breaks=300)
hist(depth$MEAN_DEPTH, breaks=3000)
hist(depth$MEAN_DEPTH, breaks=1000)
hist(depth$MEAN_DEPTH, breaks=1000, xlab='Mean SNP depth', ylab='number of SNPs')
hist(depth$MEAN_DEPTH, breaks=1000, xlab='Mean SNP depth', ylab='number of SNPs', main='Mean SNP depth')
hist(log10(depth$MEAN_DEPTH), breaks=1000, xlab='Mean SNP depth', ylab='number of SNPs', main='Mean SNP depth')
hist(log10(depth$MEAN_DEPTH), breaks=100, xlab='Mean SNP depth', ylab='number of SNPs', main='Mean SNP depth')
hist(log10(depth$MEAN_DEPTH), breaks=50, xlab='Mean SNP depth', ylab='number of SNPs', main='Mean SNP depth')
hist(log10(depth$MEAN_DEPTH), breaks=20, xlab='Mean SNP depth', ylab='number of SNPs', main='Mean SNP depth')
abline(v=5, col='red', lty=2)
abline(v=log10(5), col='red', lty=2)
abline(v=log10(100), col='red', lty=2)
source("box_lines.R")
setwd("~/Documents/Internship/chalcid_comparative_analysis/analyses/")
source("box_lines.R")
?linebox
??linebox
attach(chrom_stat)
chrom_stat$hom <- (Obs.Hom.x * N.x + Obs.Hom.y * N.y)/(N.x + N.y)
library(ggplot2); library(dplyr);library(viridis)
stat_path <- '../../data/populations/d-5_r-10/'
indv <- read.table('../../data/individuals', header=T)
setwd("~/Documents/Master/master_project/src/assoc_mapping/")
stat_path <- '../../data/populations/d-5_r-10/'
indv <- read.table('../../data/individuals', header=T)
grouped <- "T"
if(grouped=='F'){
sum_stat <- data.frame()
for(fam in list.dirs(stat_path)[2:length(list.dirs(stat_path))]){  # Excluding first dir (parent)
tmp_stat <- read.csv(paste0(fam,'/batch_0.sumstats.tsv'),header=T,skip=2,sep='\t')
tmp_stat$fam <- rep(basename(fam))
sum_stat <- rbind(sum_stat, tmp_stat)
mother_hom <- NULL
}
rm_snps<- sum_stat %>%
group_by(fam,Locus.ID,Col) %>%  # Each group contains one SNP (both male and female pop)
summarise(hom_mot = sum(Pop.ID=='F' & Q.Nuc=='-'))  # If all females are homozygous -> mother is homozygous
rm_snps <- rm_snps[rm_snps$hom_mot==0, 1:3]
sum_stat <- merge(sum_stat,rm_snps,by=c("Locus.ID","Col","fam"))
}else{
sum_stat <- read.csv(paste0(stat_path,"/batch_0.sumstats.tsv"), header=T, skip=2, sep='\t')
sum_stat$fam <- 'all'
}
male_stat <- sum_stat[sum_stat$Pop.ID=="M",c('Chr','BP','Obs.Hom', 'fam', 'N',"Locus.ID")]
female_stat <- sum_stat[sum_stat$Pop.ID=="F",c('Chr','BP','Obs.Hom', 'fam', 'N')]
chrom_stat <- merge(male_stat,female_stat,by=c('Chr','BP','fam'))
attach(chrom_stat)
chrom_stat$hom <- (Obs.Hom.x * N.x + Obs.Hom.y * N.y)/(N.x + N.y)
chrom_stat <- rename(chrom_stat, Nm=N.x,Nf=N.y, Male.Hom=Obs.Hom.x, Fem.Hom=Obs.Hom.y)
chrom_stat$weight <- chrom_stat$Nf + chrom_stat$Nm
chrom_stat <- chrom_stat[grep("chr.*", chrom_stat$Chr),]
chrom_stat$Chr <- droplevels(chrom_stat$Chr)
ggplot(chrom_stat, aes(x=BP, y=hom, weight=weight)) + facet_grid(~Chr, scales='free_x') +
geom_point(col='grey70') + stat_smooth(fill='steelblue', method='loess', fullrange = F, span=0.4)
